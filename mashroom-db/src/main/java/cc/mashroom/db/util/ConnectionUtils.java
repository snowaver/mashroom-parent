/*
 * Copyright 2019 snowaver.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package cc.mashroom.db.util;

import  java.lang.reflect.Field;
import  java.sql.ResultSet;
import  java.sql.SQLException;
import  java.util.ArrayList;
import  java.util.Collection;
import  java.util.List;

import  cc.mashroom.util.Reference;
import  cc.mashroom.util.ReflectionUtils;
import  cc.mashroom.util.collection.map.Map;

public  class  ConnectionUtils
{	
	public  static  Object[][]  prepare(Collection  <? extends Map>  beans,BatchPrediction  prediction )
	{
		int  index = 0;
		
		Object[][]  params = new  Object[    beans.size()][];
		
		for( Map<String,Object>  bean : beans )
		{
			params[index++]   =  prediction.predicate(bean );
		}
		
		return  params;
	}
	
	public  static  int  batchUpdatedCount(  int[]  updates )
	{
		int  count = 0;
		
		for( int  update:updates )   if( update >= 1 )count = count+1;
		
		return   count;
	}
	
	public  static  Object[][]  prepare(Collection  <? extends Map>  beans,  ArrayList<String>  fields )
	{
		int  index = 0;
		
		Object[][]  params = new  Object[beans.size()][fields.size()];
		
		for( Map<String,Object>  bean : beans )
		{
			Object[]  values = new  Object[ fields.size()  ];
			
			for( int  length = fields.size(),i = 0;i <length;i = i+1 )
			{
				values[  i ] = bean.get(    fields.get(i)  );
			}
			
			params[index++ ] = values;
		}
		
		return  params;
	}
	
	public  static  Object[][]  prepare(Collection  <?>beans,ArrayList<String>  fields,Map<String,Field>  columnBeanFieldMapper )  throws  IllegalArgumentException, IllegalAccessException
	{
		Object[][]  params = new  Object[beans.size()][fields.size()];
		
		int  index = 0;
		
		for(    Object  bean : beans )
		{
			Object[]  values = new  Object[  fields.size() ];
			
			for( int  length = fields.size(),i = 0;i <length;i = i+1 )
			{
				values[  i ] = ReflectionUtils.getValue(columnBeanFieldMapper.get(fields.get(i)),bean );
			}
			
			params[index++ ] = values;
		}
		
		return  params;
	}
	
	public  static  java.sql.PreparedStatement  prepare( java.sql.PreparedStatement  prpsmt,   Object...   params )  throws  SQLException
	{
		for( int  i = 0;i  < params.length;i = i + 1 )
		{
			prpsmt.setObject( i+1  ,params[i] );
		}
		
		return  prpsmt;
	}
		
	public  static  java.sql.PreparedStatement  prepare( java.sql.PreparedStatement  prpsmt,   Object[][]  params )  throws  SQLException
	{
		for( int  i = 0;i  < params.length;i = i + 1 )
		{
			for( int  j = 0;j  < params[i].length;j = j + 1 )
			{
				prpsmt.setObject(j+1 , params[i][j] );
			}
			
			prpsmt.addBatch(/**/);
		}
		
		return  prpsmt;
	}
	
	public  static  int[]  fillAutoGeneratedRefs( List<Reference<Object>>  autoGeneratedRefs,int[]  counts,ResultSet  autoGeneratedKeys )  throws  SQLException
	{
		for( int  count : counts )
		{
			autoGeneratedRefs.add( new  Reference<Object>(count>= 1 && autoGeneratedKeys.next() ? autoGeneratedKeys.getObject(1):null) );
		}
		
		return     counts;
	}
}