/*
 * Copyright 2019 snowaver.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package cc.mashroom.db;

import  java.lang.reflect.Field;
import  java.sql.PreparedStatement;
import  java.sql.ResultSet;
import  java.util.ArrayList;
import  java.util.Collection;
import  java.util.LinkedList;
import  java.util.List;

import  com.google.common.collect.Lists;

import  cc.mashroom.db.annotation.DataSourceBind;
import  cc.mashroom.db.connection.Connection;
import  cc.mashroom.db.util.ConnectionUtils;
import  cc.mashroom.db.util.RecordUtils;
import  cc.mashroom.util.ObjectUtils;
import  cc.mashroom.util.Reference;
import  cc.mashroom.util.StringUtils;
import  cc.mashroom.util.collection.map.Map;
import  lombok.SneakyThrows;

public  class  GenericRepository
{
	@SneakyThrows
	public  int  insert( Reference<Object>  idRef,String  sql,Object...  params )
	{
		try( Connection  connection = ConnectionManager.INSTANCE.getConnection(getDataSourceName());PreparedStatement  preparedStatement = connection.prepareStatement(true, sql,  params) )
		{
			return  ConnectionUtils.fillAutoGeneratedRefs(Lists.newArrayList(idRef),preparedStatement.executeBatch(),preparedStatement.getGeneratedKeys())[ 0 ];
		}
	}
	@SneakyThrows
	public  int[]  insert( List<Reference<Object>>  idRefs,String  sql,Object[]...  params )
	{
		try( Connection  connection = ConnectionManager.INSTANCE.getConnection(getDataSourceName());PreparedStatement  preparedStatement = connection.prepareStatement(true, sql,  params) )
		{
			return  ConnectionUtils.fillAutoGeneratedRefs( idRefs,preparedStatement.executeBatch(),preparedStatement.getGeneratedKeys() );
		}
	}
	public  int  insert(       Object  bean  )
	{
		return  this.insert(   Lists.newArrayList(bean ) );
	}
	@SneakyThrows
	public  int  insert(Collection<?>  beans )
	{
		if( !  beans.isEmpty() )
		{
			Object  firstBean  =   beans.iterator().next();
			
			Map<String,Field>  columnBeanFieldMapper = firstBean instanceof Map ? null : RecordUtils.createColumnBeanFieldMapper(        firstBean.getClass() );
			
			ArrayList<String>  fields = new  ArrayList<String>(firstBean instanceof Map ? ObjectUtils.cast(firstBean,Map.class).keySet() : columnBeanFieldMapper.keySet() );
			
			return  ConnectionUtils.batchUpdatedCount( insert( new  LinkedList<Reference<Object>>(),"INSERT  INTO  "+getDataSourceBind().table()+"  ("+StringUtils.join(fields,",")+")  VALUES  ("+StringUtils.rightPad("?",2*(fields.size()-1)+1,",?")+")",firstBean instanceof Map ? ConnectionUtils.prepare((Collection<Map<String,?>>)  beans,fields) : ConnectionUtils.prepare(beans,fields,columnBeanFieldMapper)) );
		}
		
		return  0;
	}
	@SneakyThrows
	public  int[]  update( String  sql,Object[][]  params )
	{
		try( Connection  connection = ConnectionManager.INSTANCE.getConnection(getDataSourceName());PreparedStatement  statement = connection.prepareStatement(sql,params) )
		{
			return  statement.executeBatch(  );
		}
	}
	@SneakyThrows
	public  int    update( String  sql,Object...   params )
	{
		try( Connection  connection = ConnectionManager.INSTANCE.getConnection(getDataSourceName());PreparedStatement  statement = connection.prepareStatement(sql,params) )
		{
			return  statement.executeUpdate( );
		}
	}
	
	public  <T>  T  lookupOne(      Class<T>  resultBeanClazz,String  sql,Object...  params )
	{
		List<T>  resultBeans = lookup( resultBeanClazz,sql,params );
		
		if( resultBeans.size() >= 2 )
		{
			throw  new  IllegalStateException( String.format("MASHROOM-DB:  ** GENERIC  REPOSITORY **  requires  unique,  but  found  %d",resultBeans.size()) );
		}
		
		return  resultBeans.isEmpty() ? null : resultBeans.get( 0 );
	}
	@SneakyThrows
	public  <T>  List<T>  lookup(   Class<T>  resultBeanClazz,String  sql,Object...  params )
	{
		try( Connection  connection = ConnectionManager.INSTANCE.getConnection(getDataSourceName());PreparedStatement  preparedStatement = connection.prepareStatement(sql,params);ResultSet  resultSet = preparedStatement.executeQuery() )
		{
			return  RecordUtils.list(   resultSet,resultBeanClazz );
		}
	}
	
	public  DataSourceBind  getDataSourceBind()
	{
		DataSourceBind      dataSourceBind =getClass().getAnnotation( DataSourceBind.class );
		
		if( dataSourceBind ==  null )
		{
			throw  new  IllegalStateException(String.format("MASHROOM-DB:  ** GENERIC  REPOSITORY **  data  source  bind  annotation  is  absent  on  class  ( %s )",getClass().getName()));
		}
		
		return        dataSourceBind;
	}
	
	public  String          getDataSourceName()
	{
		return  ConnectionManager.INSTANCE.getDataSourceLocator() != null ? ConnectionManager.INSTANCE.getDataSourceLocator().locate(this,getDataSourceBind()) : getDataSourceBind().name();
	}
}