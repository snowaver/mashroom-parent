/*
 * Copyright 2019 snowaver.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package cc.mashroom.db;

import  java.sql.PreparedStatement;
import  java.sql.ResultSet;
import  java.util.Collection;
import  java.util.LinkedList;
import  java.util.List;

import  org.apache.commons.lang3.StringUtils;

import  com.google.common.collect.Lists;

import  cc.mashroom.db.annotation.DataSourceBind;
import  cc.mashroom.db.connection.Connection;
import  cc.mashroom.db.util.ConnectionUtils;
import  cc.mashroom.util.Reference;
import  cc.mashroom.util.collection.map.HashMap;
import  cc.mashroom.util.collection.map.Map;
import  lombok.Setter;
import  lombok.SneakyThrows;
import  lombok.experimental.Accessors;

public  class  Record  extends  HashMap<String,Object>
{
	@Accessors( chain=true )
	@Setter
	protected   String  dataSourceName;
		
	@SneakyThrows
	public  int  insert( Collection<? extends Map>  recos )
	{
		if( !recos.isEmpty() )
		{
			List<String>  fields = new  LinkedList<String>( recos.iterator().next().keySet() );
			
			return  ConnectionUtils.batchUpdatedCount( insert(new  LinkedList<Reference<Object>>(),"INSERT  INTO  "+getDataSourceBind().table()+"  ("+StringUtils.join(fields,",")+")  VALUES  ("+StringUtils.rightPad("?",2*(fields.size()-1)+1,",?")+")",ConnectionUtils.prepare(Lists.newArrayList(recos),fields).toArray(new  Object[recos.size()][])) );
		}
		
		return  0;
	}
	
	@SneakyThrows
	public  int[]  update( String  sql,Object[][]  params )
	{
		try( Connection  connection = ConnectionFactory.getConnection(getDataSourceName());PreparedStatement  statement = connection.prepareStatement(sql,params) )
		{
			return  statement.executeBatch( );
		}
	}
	
	@SneakyThrows
	public  int    update( String  sql,Object...   params )
	{
		try( Connection  connection = ConnectionFactory.getConnection(getDataSourceName());PreparedStatement  statement = connection.prepareStatement(sql,params) )
		{
			return  statement.executeUpdate();
		}
	}
	
	@SneakyThrows
	public  int  insert(  Reference<Object>  keyRef,String  sql,Object...  params )
	{
		try( Connection  connection = ConnectionFactory.getConnection(getDataSourceName());PreparedStatement  preparedStatement = connection.prepareStatement(true,sql,params) )
		{
			int  counts= preparedStatement.executeUpdate();
			
			ResultSet  autoGeneratedKeySet  = preparedStatement.getGeneratedKeys();
			
			if( autoGeneratedKeySet.next()   )  keyRef.set( autoGeneratedKeySet.getObject(1) );
			
			return  counts;
		}
	}
	
	@SneakyThrows
	public  int[]  insert(   List<Reference<Object>>  keyRefs,String  sql,Object[]...  params )
	{
		try( Connection  connection = ConnectionFactory.getConnection(getDataSourceName());PreparedStatement  preparedStatement = connection.prepareStatement(true,sql,params) )
		{
			int[]  counts=preparedStatement.executeBatch();
			
			ResultSet  autoGeneratedKeySet  = preparedStatement.getGeneratedKeys();
			
			for(  int  count : counts )
			{
				keyRefs.add( new  Reference<Object>(count >= 1 && autoGeneratedKeySet.next() ? autoGeneratedKeySet.getObject(1) : null) );
			}
			
			return  counts;
		}
	}
	
	public  DataSourceBind getDataSourceBind()
	{
		return  !getClass().isAnnotationPresent(DataSourceBind.class) ? null : getClass().getAnnotation( DataSourceBind.class );
	}
	
	public  String  getDataSourceName()
	{
		if( StringUtils.isNotBlank( this.dataSourceName ) )
		{
			return this.dataSourceName;
		}
		
		return  "*".equals(getDataSourceBind().name()) ? System.getProperty( "mashroom.db.datasource.name" ) : getDataSourceBind().name();
	}
}